<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OD之断点一步到胃</title>
      <link href="/2024/07/25/OD%E4%B9%8B%E6%96%AD%E7%82%B9%E4%B8%80%E6%AD%A5%E5%88%B0%E8%83%83/"/>
      <url>/2024/07/25/OD%E4%B9%8B%E6%96%AD%E7%82%B9%E4%B8%80%E6%AD%A5%E5%88%B0%E8%83%83/</url>
      
        <content type="html"><![CDATA[<p>​常用的断点有INT3断点、硬件断点、内存断点、消息断点等。在调试时，合理使用断点能大大提高效率。</p><ol><li><p>INT3断点</p><p>​这是一个常用的断点。在OllyDbg中可以使用bp命令或者“F2”快捷键来设置&#x2F;取消断点。当执行一个INT3断点时，该地址处的内容被调试器用INT3指令替换了，此时OllyDbg将INT3隐藏，显示出来的仍是中断前的指令。</p><p>​这个INT3指令，因其机器码是0xCC,也常被称为“CC指令”。当被调试进程执行INT3指令导致一个异常时，调试器就会捕捉这个异常，从而停在断点处，然后将断点处的指令恢复成原来的指令。当然，如果自己编写调试器，也可用其他指令代替INT3来触发异常。</p><p>​使用NT3断点的优点是可以设置无数个断点，缺点是改变了原程序机器码，容易被软件检测到。例如，为了防范API被下断，一些软件会检测API的首地址是否为0xCC(以此判断是否被下断)。用C语言来实现这个检测，方法是取得检测函数的地址，然后读取它的第1个字节，判断它是否等于“CC”。下面这段代码就是对MessageBoxA函数进行的断点检测。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708112830413.webp" alt="image-20240708112830413"></p><p>​程序编译后，对MessageBoxA函数下断，程序将发现自己被设断跟踪了。躲过检测的方法是将断点设在函数内部或末尾，例如将断点设在函数入口的下一行。</p></li><li><p>硬件断点</p><p>​硬件断点和DRx调试寄存器有关。在Intel CPU体系架构手册中可以找到对DRx调试寄存器的介绍</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708113040210.webp" alt="image-20240708113040210"></p><p>​DRx调试寄存器共有8个(DR0<del>DR7),每个寄存器的特性如下：<br>● DR0</del>DR3:调试地址寄存器，用于保存需要监视的地址，例如设置硬件断点。<br>● DR4~DR5:保留，未公开具体作用。<br>● DR6:调试寄存器组状态寄存器。<br>● DR7:调试寄存器组控制寄存器。</p><p>​硬件断点的原理是使用DRO、DR1、DR2、DR3设定地址，并使用DR7设定状态，因此最多设置4个断点。硬件执行断点与CC断点的作用一样，但因为硬件执行断点不会将指令首字节修改为“CC”,所以更难检测。设断方法是在指定的代码行单击右键，执行快捷菜单中的“Breakpoint’”→“Hardware,,on execution’”（“断点”→“硬件执行”)命令（也可以在命令行中设置“HE地址”)。</p></li></ol><p>​为了便于理解，这里演示一下设置硬件断点的过程。加载实例TraceMe.exe,右键单击寄存器面板窗口，执行快捷菜单中的“View debug registers”（查看调试寄存器)命令，接着在004013AAh处设置硬件断点。按“F9”键执行程序，程序就会中断在004013AAh处。查看调试寄存器，发现DR0的值为4013AAh,设置断点后，OllyDbg实际上是将DR0~DR3中的一个设置为“004013AA”,然后在DR7中设置相应的控制位。这样，当被调试进程运行到004013AAh处时，CPU就会向OllyDbg发送异常信息，OllyDbg对该信息进行初步处理后，中断程序，让用户继续操作。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708114247540.webp" alt="image-20240708114247540"></p><p>​删除硬件断点稍有些麻烦。单击菜单项“Debug’”→“Hardware breakpoints’”(“调试”→“硬件断点”)，打开硬件断点面板，单击“Delete x”按钮删除相应的硬件断点。<br>​OllyDbg提供了一个快捷键“F4”,可以执行到光标所在的行。这也是利用调试寄存器的原理,在中断后自动删除，相当于执行了一次性硬件断点。硬件断点的优点是速度快，在INT3断点容易被发现的地方使用硬件断点会有很好的效果，缺点是最多只能使用4个断点。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708114554149.webp" alt="image-20240708114554149"></p><ol start="3"><li><p>内存断点</p><p>​OllyDbg可以设置内存访问断点或内存写入断点，原理是对所设的地址赋予不可访问不可写属性，这样当访问&#x2F;写入的时候就会产生异常。OllyDbg截获异常后，比较异常地址是不是断点地址，如果是就中断，让用户继续操作。</p><p>​因为每次出现异常时都要通过比较来确定是否应该中断，所以内存断点会降低OllyDbg的执行速度一也许OllyDbg是考虑到执行速度才规定只能下1个内存断点吧。</p><p>​程序运行时有3种状态，分别是读取、写入和执行。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708115026150.webp" alt="image-20240708115026150"></p><p>​用OllyDbg重新加载实例TraceMe.exe,看到004013D0h处有一个写内存的指令，代码如下。</p></li></ol><p>​<img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708142638318.webp" alt="image-20240708142638318"></p><p>​下面用这个地址来演示如何下内存断点。在数据窗口中对00405528h处下内存写断点，将光标移到00405528h处，选中需要下断点的地址区域，单击右键，执行快捷菜单中的“Breakpoint’→“Memory,.on write”（“断点”→“内存写入”)命令</p><p>​下内存写断点后，按“F9”键让程序运行，程序会马上中断在“4013D0mov[405528,edx]”这行。如果要清除内存断点，可以单击右键，执行快捷菜单中的“Breakpoint’”→“Remove memorbreakpoint’”（“断点”→“删除内存断点”)命令。内存访问断点的操作与此类似。</p><p>​在这个场景中，硬件断点也可以实现与内存断点相同的效果。单个硬件写入访问断点可以设置为1字节、2字节或4字节，而且不论选择的数据范围有多大，只有前4个字节会起作用。打开数据窗口，选中需要下断点的地址区域，单击右键，执行快捷菜单中的“Breakpoint”→“Hardware,onwrite”→“Dword”(“断点”·“硬件写入”→“Dword’”)命令。</p><p>​重新加载TraceMe,会发现程序中断在触发硬件写人断点的下一条指令处，所以请记住：硬件访问&#x2F;写入断点是在触发硬件断点的下一条指令处下断，而内存断点是在触发断点的指令处下断。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708143917773.webp" alt="image-20240708143917773"></p><p>​对代码也可下内存访问断点。在OllyDbg里重新加载实例TraceMe..exe,任意定位一行代码，例如004013D6h处，单击右键，执行快捷菜单中的“Breakpoint”一→“Memory,on access”（“断点”“内存访问”)命令</p><p>​当然，执行内存004013D6h处的代码时需要“访问”它，因此，按“F9”键让实例在OllyDbg里运行，就会中断在004013D6h处的内存访问断点上。这个实验表明，在内存执行的地方也可以通过内存访问来中断。内存断点不修改原始代码，不会像INT3断点那样因为修改代码被程序校验而导致下断失败。因此，在遇到代码校验且硬件断点失灵的情况下，可以使用内存断点。</p><ol start="4"><li>内存访问一次性断点</li></ol><p>​Windows对内存使用段页式的管理方式。在OllyDbg里按“Alt+M”快捷键显示内存，可以看到许多个段，每个段都有不可访问、读、写、执行属性。在相应的段上单击右键，会在快捷菜单中发现一个命令“Set break-on-access’”(在访问上设置断点，其快捷键是“F2”,用于对整个内存块设置该类断点。这个断点是一次性断点，当所在段被读取或执行时就会中断。中断发生以后，断点将被删除。如果想捕捉调用或返回某个模块，该类断点就显得特别有用了。右键快捷菜单中的“Set memory breakpoint on access”(设置内存访问断点)命令和“Set break-on-access”命令的功能大致相同，所不同的是前者不是一次性断点。这类断点仅在NT架构下可用。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708145000914.webp" alt="image-20240708145000914"></p><ol start="5"><li><p>消息断点</p><p>​Windows本身是由消息驱动的，如果调试时没有合适的断点，可以尝试使用消息断点。当某个特定窗口函数接收到某个特定消息时，消息断点将使程序中断。消息断点与INT3断点的区别在于：INT3断点可以在程序启动之前设置，消息断点只有在窗口被创建之后才能被设置并拦截消息。<br>​当用户单击一个按钮、移动光标或者向文本框中输人文字时，一条消息就会发送给当前窗体。所有发送的消息都有4个参数，分别是1个窗口句柄(hwnd)、1个消息编号(msg)和2个32位长(long)的参数。Windows通过句柄来标识它所代表的对象。例如，在单击某个按钮时，Windows通过句柄来判断单击了哪一个按钮，然后发送相应的消息来通知程序。</p><p>​下面用实例TraceMe演示如何设置消息断点。在OllyDbg里运行实例，输入用户名和序列号，单击莱单项“View”→“Windows’”(“查看”→“窗口”)或工具栏中的W按钮，列出窗口相关参数。如果界面上没有内容，应执行右键快捷菜单中的“Actualize’”(刷新)命令。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708151530825.webp" alt="image-20240708151530825"></p><p>​这里列出了所有属于被调试程序窗口及与窗口相关的重要参数，例如按钮、对应的ID及句柄(Handle)等。现在要对“Check”按钮下断点，即当单击该按钮时程序中断。在“Check”条目上单击右键，在弹出的快捷菜单中，执行“Message breakpoint on ClassProc”(在ClassProc上设置消息断点)命令，会弹出如图所示的设置窗口，下拉列表中显示了文本控件、按钮、鼠标等类型的消息。如果选择第1项“Any Message””,将拦截所有消息。我们在这里关注的消息属于“Button’”(按钮)这一项，当单击按钮并松开时，会发送“WM LBUTTONUP”这个消息。单击下拉菜单，选择“202 WM LBUTTONUP”选项，再单击“OK”按钮，消息断点就设置好了。单击选中“Break on any window”单选按钮，表示程序的任何窗口收到该消息后都会中断。“Log WinProc arguments”是用于记录消息过程函数的参数。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708151936150.webp" alt="image-20240708151936150"></p><p>​回到TraceMe界面，单击“Check”按钮。松开鼠标时，程序将中断在Windows系统代码中，代码如下（不同版本的操作系统，代码会不同）。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708152033708.webp" alt="image-20240708152033708"></p><p>​消息已经捕捉到了，但还处于系统底层代码中，不属于TraceMe主程序的代码，这时企图使用“Alt+f9”或“Crl+F9”快捷键返回TraceMe程序代码领空的操作是徒劳的。</p></li></ol><p>​主程序的代码在以00401000h开头的text区块里。从系统代码回到应用程序代码段的时候，正是.text区块代码执行的时候，因此，对，text区块下内存断点就能返回应用程序的代码领空。按“Al+M”快捷键打开内存窗口，对text区块下内存访问断点，然后执行右键快捷菜单中的命令“Setbreak-on-access’”(在访问上设置断点)或按快捷键“F2”</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708152647327.webp" alt="image-20240708152647327"></p><p>​按“F9”键运行程序，程序立即中断在004010D0h处，这里正是程序的消息循环处，代码如下。</p><p>​<img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240708152855957.webp"></p><p>​这段代码是一个消息循环，不停地处理TraceMe主界面的各类消息。此时可能不会直接处理按钮事件。如果是单步跟踪，会进入系统代码。在系统代码里，再次</p><p>​按“At+M”快捷键打开内存窗口，对.text区块下内存访问断点。按“f9”键运行，会再次来到代码中。重复这个过程，在一两次中断后就能到达处理按钮的事件代码处       了。“Chek”按钮的事件代码如下。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240709103012918.webp" alt="image-20240709103012918"></p><p>​最后，可以将消息断点删除。按“Alt+B”快捷键切换到断点窗口，选中消息断点，直接将其删除。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240709104455427.webp" alt="image-20240709104455427"></p><ol start="6"><li>条件断点</li></ol><p>​在调试过程中，我们经常希望断点在满足一定条件时才会中断，这类断点称为条件断点。OllyDbg的条件断点可以按寄存器、存储器、消息等设断。条件断点是一个带有条件表达式的普通INT3断点。当调试器遇到这类断点时，断点将计算表达式的值，如果结果非零或者表达式有效，则断点生效（暂停被调试程序)。</p><p>​（1）按寄存器条件中断</p><p>​OD打开Conditional_bp.exe，在00401476h处按下设置条件斯点的快捷键“Shift+F2”,在条件文本框内输入条件表达式“eax&#x3D;&#x3D;0400000”。这样，程序在执行到00401476h处时，如果eax的值为0400000h,OllyDbg将会中断。如果安装了命令行插件，也可在命令行里直接输人如下命令。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240709105246966.webp" alt="image-20240709105246966"></p><p>​<img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240709105049423.webp" alt="image-20240709105049423"></p><p>​（2）按存储器条件中断</p><p>​在这里用CreateFileA函数进行演示。在实际应用中程序可能会成百上千次调用CreateFileA函数，因此让OllyDbg在CreateFileA函数打开所需文件时中断就显得十分有必要了。CreateFile函数的代码原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateFileA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           LPCSTR                lpFileName,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwDesiredAccess,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwShareMode,</span></span><br><span class="line"><span class="params">  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwCreationDisposition,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwFlagsAndAttributes,</span></span><br><span class="line"><span class="params">  [in, optional] HANDLE                hTemplateFile</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>​运行实例Conditional_bp,对CreateFileA函数设断。单击“OpenTest’”按钮，如图是当OllyDg中断时从栈中看到的情形，左侧标出了各参数相对于当前ESP的地址。打开这个功能的方法是：在栈窗口中单击右键，执行快捷菜单中的“Address’”→“Relative to ESP”(“地址”+“相对于ESP”)命令。</p><p>​<img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240709111019091.webp" alt="image-20240709111019091"></p><p>​CreateFileA函数采用标准调用约定，参数按从右到左的顺序人栈。因为在函数刚执行时EBP栈结构还未建立，所以只能用ESP访问这些参数。CreateFileA函数的第1个参数“FileName”是文件名指针。在OllyDbg里，如果要得到第1个参数的内存地址，可以使用“[ESP+4]”;如果还要得到此地址指向的字符串，就必须使用“[ESP+4]”。</p><p>​该实例中调用了4次CreateFileA函数，假设要在该函数打开c:\1212.txt时下断，则”shitf+f2“，输入<code>[STRING [esp+4]]==&quot;c:\\1212.txt&quot;</code>(“STRING”前缀在OllyDbg中的解释是“以零结尾的ASCIl字符串”,如果是Unicode字符串，则改为UNICODE)</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240709111858405.webp" alt="image-20240709111858405"></p><ol start="7"><li><p>条件记录断点</p><p>​条件记录断点除了具有条件断点的作用，还能记录断点处函数表达式或参数的值。也可以设置通过断点的次数，每次符合暂停条件时，计数器的值都将减1。例如，要记录Conditional_bp实例调用CreateFileA函数的情况，可在CreateFileA函数的第1行按快捷键Shft+F4”,打开条件记录窗口.在“Condition”(条件)域中输入要设置的条件表达式。在“Explanation”(说明）域中设置一个名称。“Expression”(表达式)域中是要记录的内容的条件，只能设置1个表达式，例如要记录EAX的值，可以输“EAX”。“Decode value of expression as’”(解码表达式的值)下拉列表中可以对记录的数据进行分析。例如，在条件记录窗口中，如果“Expression”域中填写的是[esp+4],则要在该下拉列表中选择“Pointer to ASCIIString”(指向AsCIl字符串的指针)选项，才能得到正确的结果，其功能相当于“STRING”前缀.</p><p>​“Pause program”(暂停程序)域用于设置OllyDhg遇到断点时是否中断。“Log value of expression(记录表达式的值)域用于设置遇到断点时是否记录表达式的值。“Log function arguments’”(记录数参数)域用于设置遇到断点时是否记录函数的参数。对这3个域，可以根据需要设置“Never’”(不)、“On condition”(按条件)或“Always”(永远)。<br>​条件记录断点允许向插件传递1个或多个命令。当应用程序因条件断点暂停，并且断点中包传递给插件的命令时，都会调用回调函数ODBG_Plugincmd(int reason,t_reg*registers,char*cmd)。如,当程序暂停时，传送命令“d esp”给CmdBar插件，只要在窗口的文本框中输”.d esp”，当条件断点断下时，就会执行“d esp”命令。这时，我们就可以在数据窗口中看到ESP地址处的数据了。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240709115926084.webp" alt="image-20240709115926084"></p><p>​设置好条件记录断点，单击实例Conditional_.bp的“OpenTest”按钮，运行后，OllyDbg会在“Logdata”窗口（快捷键“Alt+L”)记录数据。</p></li></ol><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240709115945123-1720497892426-61.webp" alt="image-20240709115945123"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>32位下函数分析要点一步到&quot;胃&quot;</title>
      <link href="/2024/07/25/32%E4%BD%8D%E4%B8%8B%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E8%A6%81%E7%82%B9%E4%B8%80%E6%AD%A5%E5%88%B0%E8%83%83/"/>
      <url>/2024/07/25/32%E4%BD%8D%E4%B8%8B%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E8%A6%81%E7%82%B9%E4%B8%80%E6%AD%A5%E5%88%B0%E8%83%83/</url>
      
        <content type="html"><![CDATA[<p>​程序都是由具有不同功能的函数组成的，因此在逆向分析中将重点放在函数的识别及参数的传递上是明智的，这样做可以将注意力集中在某一段代码上。函数是一个程序模块，用来实现一个特定的功能。一个函数包括函数名、入口参数、返回值、函数功能等部分。</p><p>​<code>函数的识别：</code>程序通过调用程序来调用函数，在函数执行后又返回调用程序继续执行。函数如何知道要返回的地址呢？实际上，调用函数的代码中保存了一个返回地址，该地址会与参数一起传递给被调用的函数。有多种方法可以实现这个功能，在绝大多数情况下，编译器都使用call和ret指令来调用函数及返回调用位置。</p><p>​call指令与跳转指令功能类似。不同的是，call指令保存返回信息，即将其之后的指令地址压入栈的顶部，当遇到ret指令时返回这个地址。也就是说，call指令给出的地址就是被调用函数的起始地址。ret指令则用于结束函数的执行（当然，不是所有的ret指令都标志着函数的结束）。通过这一机制可以很容易地把函数调用和其他跳转指令区别开来。<br>​因此，可以通过定位call机器指令或利用ret指令结束的标志来识别函数。call指令的操作数就是所调用函数的首地址。看一个例子，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">main( )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">6</span>;</span><br><span class="line">    Add(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Add(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​编译结果如下</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240715141146105.webp" alt="image-20240715141146105"></p><p>​这种函数直接调用方式使程序变得很简单一所幸大部分情况都是这样的。但也有例外，程序调用函数是间接调用的，即通过寄存器传递函数地址或动态计算函数地址调用。例如<code>CALL [4*eax+10h]</code></p><p>​<code>函数的参数：</code>函数传递参数有3种方式，分别是栈方式、寄存器方式及通过全局变量进行隐含参数传递的方式。如果参数是通过栈传递的，就需要定义参数在栈中的顺序，并约定函数被调用后由谁来平衡栈。如果参数是通过寄存器传递的，就要确定参数存放在哪个寄存器中。每种机制都有其优缺点，且与使用的编译语言有关。</p><p>​（1）利用栈传递参数</p><p>​栈是一种“后进先出”的存储区，栈顶指针esp指向栈中第1个可用的数据项。在调用函数时，调用者依次把参数压入栈，然后调用函数。函数被调用以后，在栈中取得数据并进行计算。函数计算结束以后，由调用者或者函数本身修改栈，使栈恢复原样（即平衡栈数据)。<br>​在参数的传递中有两个很重要的问题：当参数个数多于1个时，按照什么顺序把参数压人栈？函数结束后，由谁来平衡栈？这些都必须有约定。这种在程序设计语言中为了实现函数调用而建立的协议称为调用约定(Calling Convention)。这种协议规定了函数中的参数传送方式、参数是否可变和由谁来处理栈等问题。不同的语言定义了不同的调用约定，常用的调用约定如下。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240715141839888.webp" alt="image-20240715141839888"></p><p>​C规范（即__cdecl)函数的参数按照从右到左的顺序人栈，由调用者负责清除栈。__cdecl是C和C++程序的默认调用约定。C&#x2F;C+和MFC程序默认使用的调用约定是、__cdecl,也可以在函数声明时加上__cdecl关键字来手动指定。<br>​pascal规范按从左到右的顺序压参数人栈，要求被调用函数负责清除栈。<br>​stdcall调用约定是Win32API采用的约定方式，有“标准调用”(Standard CALL)之意，采用C调用约定的入栈顺序和pascal调用约定的调整栈指针方式，即函数入口参数按从右到左的顺序入栈，并由被调用的函数在返回前清理传送参数的内存栈，函数参数的个数固定。由于函数体本身知道传入的参数个数，被调用的函数可以在返回前用一条retn指令直接清理传递参数的栈。在Win32API中，也有一些函数是__cdecl调用的，例如wsprintf。</p><p>​为了了解不同类型约定的处理方式，我们来看一个例子。假设有调用函数test1(Parl,Par2,Par3)按__cdecl、pascal和stdeall的调用约定，其汇编代码如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cdecl:</span><br><span class="line">push par3 ;参数从右到左传递</span><br><span class="line">push par2</span><br><span class="line">push par1</span><br><span class="line">call test1</span><br><span class="line">add esp,0c ;平衡栈</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pascal:</span><br><span class="line">push par1 ;参数从左到右传递</span><br><span class="line">push par2</span><br><span class="line">push par3</span><br><span class="line">call test1 ;函数内平衡栈</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stdcall:</span><br><span class="line">push par3 ;参数从右到左传递</span><br><span class="line">push par2</span><br><span class="line">push par1</span><br><span class="line">call test1 ;函数内平衡栈</span><br></pre></td></tr></table></figure><p>​可以清楚地看到，__cdecl类型和stdcall类型先把右边的参数压人栈，pascal则相反。在栈平衡上，__cdecl类型由调用者用“add esp,0c”指令把12字节的参数空间清除，pascal和stdcall类型则由子程序负责清除。<br>​函数对参数的存取及局部变量都是通过栈来定义的，非优化编译器用一个专门的寄存器（通常是ebp)对参数进行寻址。C、C+、pascal等高级语言的函数（子程序）执行过程基本一致，情祝如下。 </p><p>​调用者将函数（子程序）执行完毕时应返回的地址、参数压入栈。</p><p>​子程序使用“ebp指针+偏移量”对栈中的参数进行寻址并取出，完成操作。<br>​子程序使用ret或retf指令返回。此时，CPU将eip置为栈中保存的地址，并继续执行它。</p><p>​栈在整个过程中发挥着非常重要的作用。栈是一个先进后出的区域，只有一个出口，即当前栈顶。栈操作的对象只能是双操作数（占4字节）。例如，按stdcall约定调用函数test2(Parl,Par2)(有2个参数)，其汇编代码大致如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">push par2 ;参数2</span><br><span class="line">push par1 ;参数1</span><br><span class="line">call test2 ;调用子程序test2</span><br><span class="line">&#123;</span><br><span class="line">push ebp  ;保护现场，原来的ebp指针</span><br><span class="line">mov ebp, esp  ;设置新的ebp，使其指向栈顶</span><br><span class="line">mov eax, dword ptr [ebp+0c]    ;调用参数2</span><br><span class="line">mov ebx, dword ptr [ebp+08]    ;调用参数1</span><br><span class="line">sub esp, 8  ;若函数要使用局部变量，则要再栈中留出一部分空间</span><br><span class="line">......</span><br><span class="line">add esp, 8 ;释放局部变量占用的栈</span><br><span class="line">pop ebp ;恢复现场的ebp</span><br><span class="line">ret 8 ;返回（相当于ret;add esp,8）</span><br><span class="line"> ;ret后面的值等于参数个数乘4h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​因为esp是栈指针，所以一般使用ebp来存取栈。其栈建立过程如下。</p><p>​①此例函数中有2个参数，假设执行函数前栈指针的esp为K。<br>​②根据stdcall调用约定，先将参数Par2压进栈，此时esp为K-04h。<br>​③将参数Par1压人栈，此时esp为K-08h.</p><p>​④参数入栈后，程序开始执行call指令。cal指令把返回地址压人栈，这时esp为K-0Ch。<br>​⑤现在已经在子程序中了，可以开始使用ebp来存取参数了。但是，为了在返回时恢复ebp的值，需要使用“push ebp”指令来保存它，这时esp为K-10h。<br>​⑥执行“mov ebp,.esp”指令，ebp被用来在栈中寻找调用者压人的参数，这时[ebp+8]就是参数1，[ebp+c]就是参数2。<br>​⑦“sub esp,8”指令表示在栈中定义局部变量。局部变量1和局部变量2对应的地址分别是[ebp-4和[ebp-8]。函数结束时，调用“add esp,8”指令释放局部变量占用的栈。局部变量的作用域是定义该变量的函数 ，也就是说，当函数调用结束后局部变量便会消失。<br>​⑧调用“ret 8”指令来平衡栈。在ret指令后面加一个操作数，表示在ret指令后给栈指针esp加上操作数，完成同样的功能。<br>​处理完毕，就可以用ebp存取参数和局部变量了，这个过程如图所示。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240715151420270.webp" alt="image-20240715151420270"></p><p>​此外，指令enter和leave可以帮助进行栈的维护。enter语句的作用就是“push ebp”“mov ebp,esp”“sub esp,xxx”,而leave语句则完成“add esp,xxx”“pop ebp”的功能。所以，上面的程序可以改成如下形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enter xxxx,0 ;0表示创建xxxx空间来放置局部变量</span><br><span class="line">......</span><br><span class="line">leave ;恢复现场</span><br><span class="line">ret 8;返回</span><br></pre></td></tr></table></figure><p>​在许多时候，编译器会按优化方式来编译程序，栈寻址稍有不同。这时，编译器为了节省ebp寄字器或尽可能减少代码以提高速度，会直接通过esp对参数进行寻址。esp的值在函数执行期间会发生变化，该变化出现在每次有数据进出栈时。要想确定对哪个变量进行了寻址，就要知道程序当前位置的esp的值，为此必须从函数的开始部分进行跟踪。<br>​同样，对上例中的test2(Parl,Par2)函数，在VC6.0里将优化选项设置为“Maximize Speed’”。重新编译该函数，其汇编代码可能如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push par2   ;参数2</span><br><span class="line">push par1   ;参数1</span><br><span class="line">call test2   ;调用子程序test2</span><br><span class="line">&#123;</span><br><span class="line">mov eax, dword ptr [esp+04]    ;调用参数1</span><br><span class="line">mov ebx, dword ptr [esp+08]   ;调用参数1</span><br><span class="line">......</span><br><span class="line">ret 8 ;返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这时，程序就用esp来传递参数了。其栈建立情况如图所示，过程如下。<br>​①假设执行函数前栈指针esp的值为K。<br>​②根据stdcall调用约定，先将参数Par2压入栈，此时esp为K-04h。<br>​③将Par1压入栈，此时esp为K-08h。<br>​④参数入栈后，程序开始执行call指令。call指令把返回地址压人栈，这时esp为K-OCh。<br>​⑤现在已经在子程序中了，可以使用esp来存取参数了。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240715152157868.webp" alt="image-20240715152157868"></p><p>​（2）利用寄存器传递参数</p><p>​寄存器传递参数的方式没有标准，所有与平台相关的方式都是由编译器开发人员制定的。尽管没有标准，但绝大多数编译器提供商都在不对兼容性进行声明的情况下遵循相应的规范，即Fastcall规范。Fastcall,顾名思义，特点就是快（因为它是靠寄存器来传递参数的）。</p><p>​不同编译器实现的Fastcall稍有不同。Microsoft Visual C++编译器在采用Fastcall规范传递参数时，左边的2个不大于4字节(DWORD)的参数分别放在ecx和edx寄存器中，寄存器用完后就要使用栈，其余参数仍然按从右到左的顺序压入栈，被调用的函数在返回前清理传送参数的栈。浮点值，远指针和int64类型总是通过栈来传递的。而Borland Delphi&#x2F;C+编译器在采用Fastcall规范传递参数时，左边的3个不大于4字节(DWORD)的参数分别放在eax、edx和ecx寄存器中，寄存器用完后，其余参数按照从左至右的PASCAL方式压人栈。</p><p>​另有一款编译器Watcom C总是通过寄存器来传递参数，它严格为每一个参数分配一个寄存器，默认情况下第1个参数用eax,第2个参数用edx,第3个参数用ebx,第4个参数用ecx。如果寄存器用完，就会用栈来传递参数。Vatcom C可以由程序员指定任意一个寄存器来传递参数，因此，其参数实际上可能通过任何寄存器进行传递。来看一个用Microsoft Visual C++6.0编译的Fastcall调用实例，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  __fastcall <span class="title function_">Add</span><span class="params">(<span class="type">char</span>, <span class="type">long</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __fastcall <span class="title function_">Add</span><span class="params">(<span class="type">char</span> a, <span class="type">long</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b + c + d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​使用Visual C++进行编译，将“Optimizations’”选项设置为“Default’”。编译后查看其反汇编代码，具体如下。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240715160336803.webp" alt="image-20240715160336803"></p><p>​Add()函数<br>​<img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240715160347231.webp" alt="image-20240715160347231"></p><p>​另一个调用规范thiscall也用到了寄存器传递参数。thiscall是C++中的非静态类成员函数的默认调用约定，对象的每个函数隐含接收this参数。采用thiscall约定时，函数的参数按照从右到左的顺序人栈，被调用的函数在返回前清理传送参数的栈，仅通过ecx寄存器传送一个额外的参数——this指针。</p><p>​定义一个类，并在类中定义一个成员函数，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//实际Add原型具有如下形式:Add(this,int a,int b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    CSum sum;</span><br><span class="line">    sum.Add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​使用Visual C++进行编译，将“Optimizations”选项设置为“”Default’”。编译后查看其反汇编代码。<br>​<img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240715162537397.webp" alt="image-20240715162537397"></p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240715162640456.webp" alt="image-20240715162640456"></p><p>​（3）名称修饰约定</p><p>​为了允许使用操作符和函数重载，C++编译器往往会按照某种规则改写每一个入口点的符号名，从而允许同一个名字（具有不同的参数类型或者不同的作用域）有多个用法且不会破坏现有的基于C的链接器。这项技术通常称为名称改编(Name Mangling)或者名称修饰(Name Decoration)。许多C++编译器厂商都制定了自己的名称修饰方案。<br>​在VC++中，函数修饰名由编译类型(C或C++)、函数名、类名、调用约定、返回类型、参数等因素共同决定。关于名称修饰的内容很多，下面仅简单谈一下常见的C编译、C++编译函数名的修饰。</p><p>​C编译时函数名修饰约定规则如下。</p><p>​stdcall调用约定在输出函数名前面加一个下画线前缀，在后面加一个“@”符号及其参数的字节数，格式为“functionname(@number”。<br>​__cdecl调用约定仅在输出函数名前面加一个下画线前缀，格式为”_functionname”。<br>​Fastcall调用约定在输出函数名前面加一个“@”符号，在后面加一个“@”符号及其参数的字节数，格式为“@functionname@number”。</p><p>​它们均不改变输出函数名中的字符大小写。这和pascall调用约定不同。pascal约定输出的函数名不能有任何修饰且全部为大写。<br>​C++编译时函数名修饰约定规则如下。</p><p>​stdcall调用约定以“”标识函数名的开始，后跟函数名；在函数名后面，以“@@YG”标识参数表的开始，后跟参数表；参数表的第1项为该函数的返回值类型，其后依次为参数的数据类型，指针标识在其所指数据类型前：在参数表后面，以“@Z”标识整个名字的结束（如果该函数没有参数，则以“Z”标识结束）。其格式 为“? functionname@@YC****@Z”或“?functionname@@YG*XZ。<br>​__cdecl调用约定规则与上面的stdcall调用约定规则相同，只是参数表的开始标识由“@@YG”变成了“@@YA”。<br>​Fastcall调用约定规则与上面的stdcall调用约定规则相同，只是参数表的开始标识由“@@YG”变成了“@@YT”。</p><p>​<code>函数的返回值：</code>函数被调用执行后，将向调用者返回1个或多个执行结果，称为函数返回值。返回值最常见的形式是return操作符，还有通过参数按传引用方式返回值、通过全局变量返回值等。</p><p>​（1）用return操作符返回值</p><p>​在一般情况下，函数的返回值放在eax寄存器中返回，如果处理结果的大小超过eax寄存器的容量，其高32位就会放到edx寄存器中，例如下面这段C程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyAdd(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = x + y;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这是一个普通的函数，它将两个整数相加。这个函数有两个参数，并使用一个局部变量临时保存结果。其汇编实现代码所下。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240715173428513.webp" alt="image-20240715173428513"></p><p>​（2）通过参数按传引用方式返回值</p><p>​给函数传递参数的方式有两种，分别是传值和传引用。进行传值调用时，会建立参数的一份副本，并把它传给调用函数，在调用函数中修改参数值的副本不会影响原始的变量值。传引用调用允许调用函数修改原始变量的值。调用某个函数，皆把变量的地址传递给函数时，可以在函数中用间接引用运算符修改调用函数内存单元中该变量的值。例如，在调用函数max时，需要用两个地址（或者两个指向整数的指针）作为参数，函数会将结果较大的数放到参数a所在的内存单元地址中返回，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>;</span><br><span class="line">main( )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">6</span>;</span><br><span class="line">    max(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a、b中较大的数是%d&quot;</span>, a); <span class="comment">//将最大的数显示出来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">max</span><span class="params">( <span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*a &lt; *b)</span><br><span class="line">        *a = *b; <span class="comment">//经比较后，将较大的数放到a变量之中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​其汇编代码如下</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240725180625834.webp" alt="image-20240725180625834"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见数据类型分析要点一步到&quot;胃&quot;</title>
      <link href="/2024/07/25/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E6%9E%90%E8%A6%81%E7%82%B9%E4%B8%80%E6%AD%A5%E5%88%B0%E8%83%83/"/>
      <url>/2024/07/25/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E6%9E%90%E8%A6%81%E7%82%B9%E4%B8%80%E6%AD%A5%E5%88%B0%E8%83%83/</url>
      
        <content type="html"><![CDATA[<p>​</p><p>​数据结构是计算机存储、组织数据的方式。在进行逆向分析时，确定数据结构以后，算法就很容易得到了。有些时候，事情也会反过来，即根据特定算法来判断数据结构。本节将讨论常见的数据结构及它们在汇编语言中的实现方式。</p><p>​<code>局部变量：</code>局部变量(Local Variables)是函数内部定义的一个变量，其作用域和生命周期局限于所在函数内。使用局部变量使程序模块化封装成为可能。从汇编的角度来看，局部变量分配空间时通常会使用栈和寄存器。</p><p>​（1）利用栈存放局部变量</p><p>​局部变量在栈中进行分配，函数执行后会释放这些栈，程序用“sub esp,8”语句为局部变量分配空间，用[ehp-xxxx]寻址调用这些变量，而参数调用相对于ebp偏移量是正的，即[ebp+xxxx],因此在逆向时比较容易区分。编译器在优化模式时，通过esp寄存器直接对局部变量和参数进行寻址。当函数退出时，用“add esp,8”指令平衡栈，以释放局部变量占用的内存。有些编译器（例如Delphi)通过给esp加一个负值来进行内存的分配。另外，编译器可能会用“push reg’”指令取代“sub esp,4”指令，以节省几字节的空间。<br>​局部变量分配与清除栈的形式如表所示。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240716144036292.webp" alt="image-20240716144036292"></p><p>​下面这个实例是用“push reg””指令来取代“sub esp,4”指令的。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">6</span>;</span><br><span class="line">    add(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    z = x + y;</span><br><span class="line">    <span class="keyword">return</span>(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​用Microsoft Visual C+6.0进行编译，不进行忧化，其汇编代码如下。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240716144329185.webp" alt="image-20240716144329185"></p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240716144347269.webp" alt="image-20240716144347269"></p><p>​add函数里不存在“sub esp,n”之类的指令，程序通过“push ecx’”指令来开辟一块栈，然后用[ebp-04]来访问这个局部变量。局部变量的起始值是随机的，是其他函数执行后留在栈中的垃圾数据，因此需要对其进行初始化。初始化局部变量有两种方法：一种是通过mov指令为变量赋值，例如“mov[ebp-04],5”;另一种是使用push指令直接将值压人栈，例如“push 5”。</p><p>​（2）利用寄存器存放局部变量</p><p>​除了栈占用2个寄存器，编译器会利用剩下的6个通用寄存器尽可能有效地存放局部变量，这样可以少产生代码，提高程序的效率。如果寄存器不够用，编译就会将变量放到栈中。在进行逆向分析时要注意，局部变量的生存周期比较短，必须及时确定当前寄存器的变量是哪个变量。</p><p>​<code>全局变量：</code>全局变量作用于整个程序，它一直存在，放在全局变量的内存区中。局部变量则存在于函数的栈区中，函数调用结束后便会消失。在大多数程序中，常数一般放在全局变量中，例如一些注册版标记、测试版标记等。在大多数情况下，在汇编代码中识别全局变量比在其他结构中要容易得多。全局变量通常位于数据区块（.data)的一个固定地址处，当程序需要访问全局变量时，一般会用一个固定的硬编码地址直接对内存进行寻址，示例如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr [40874c0h]</span><br></pre></td></tr></table></figure><p>​全局变量可以被同一文件中的所有函数修改，如果某个函数改变了全局变量的值，就能影响其他函数（相当于函数间的传递通道），因此，可以利用全局变量来传递参数和函数返回值等。全局变量在程序的整个执行过程中占用内存单元，而不像局部变量那样在需要时才开辟内存单元。</p><p>​看一个利用全局变量传递参数的实例，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">6</span>;</span><br><span class="line">    z = <span class="number">7</span>;</span><br><span class="line">    add(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(x + y + z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​用Microsoft Visual C+6.0进行编译，但不进行优化，其汇编代码如下。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240716151649239.webp" alt="image-20240716151649239"></p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240716151700772.webp" alt="image-20240716151700772"></p><p>​用PEID打开编译后的程序，查看区块，区块信息如图所示。全局变量004084C0h在.data区块中，该区块的属性为可读写。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240716153017410.webp" alt="image-20240716153017410"></p><p>​使用这种对内存直接寻址的硬编码方式，比较容易识别出这是一个全局变量。一般编译器会将全局变量放到可读写的区块里（如果放到只读区块里，就是一个常量）。<br>​与全局变量类似的是静态变量，它们都可以按直接方式寻址等。不同的是，静态变量的作用范围是有限的，仅在定义这些变量的函数内有效。</p><p>​<code>数组：</code>数组是相同数据类型的元素的集合，它们在内存中按顺序连续存放在一起。在汇编状态下访问数组一般是通过基址加变址寻址实现的。<br>​请看下面这个数组访问实例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, s = <span class="number">0</span>, b[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = s + a[i];</span><br><span class="line">        b[i] = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​用Microsoft Visual C+6.0进行编译，将优化选项设置为“Maximize Speed”,其汇编代码如下。</p><p><img src="https://raw.githubusercontent.com/FeowmAomr/picx-images-hosting/master/image-20240716153737093.webp" alt="image-20240716153737093"></p><p>​在内存中，数组可存在于栈、数据段及动态内存中。本例中的a[ ]数组就保存在数据段.data中，其寻址用“基址+编移量”实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     edi, dword_407030[eax]</span><br></pre></td></tr></table></figure><p>​这种间接寻址一般出现在给一些数组或结构赋值的情况下，其寻址形式一般是[基址+偏移量]。基址可以是常量，也可以是寄存器，为定值。根据n值的不同，可以对结构中的相应单元赋值。<br>​b[ ]数组放在栈中，这些栈在编译时分配。数组在声明时可以直接计算偏移地址，针对数组成员寻址是采用实际的偏移量完成的。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
